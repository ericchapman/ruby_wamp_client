require 'wamp/client/check'

# !!!!THIS FILE IS AUTOGENERATED.  DO NOT HAND EDIT!!!!

module Wamp
  module Client
    module Message

      module Types
        HELLO = 1
        WELCOME = 2
        ABORT = 3
        CHALLENGE = 4
        AUTHENTICATE = 5
        GOODBYE = 6
        ERROR = 8
        PUBLISH = 16
        PUBLISHED = 17
        SUBSCRIBE = 32
        SUBSCRIBED = 33
        UNSUBSCRIBE = 34
        UNSUBSCRIBED = 35
        EVENT = 36
        CALL = 48
        CANCEL = 49
        RESULT = 50
        REGISTER = 64
        REGISTERED = 65
        UNREGISTER = 66
        UNREGISTERED = 67
        INVOCATION = 68
        INTERRUPT = 69
        YIELD = 70
      end

      class Base
        include Wamp::Client::Check

        def payload
          []
        end

        # @param params [Array]
        def self.parse(params)
          object = nil
          if params[0] == Types::HELLO
            object = Wamp::Client::Message::Hello.parse(params)
          elsif params[0] == Types::WELCOME
            object = Wamp::Client::Message::Welcome.parse(params)
          elsif params[0] == Types::ABORT
            object = Wamp::Client::Message::Abort.parse(params)
          elsif params[0] == Types::CHALLENGE
            object = Wamp::Client::Message::Challenge.parse(params)
          elsif params[0] == Types::AUTHENTICATE
            object = Wamp::Client::Message::Authenticate.parse(params)
          elsif params[0] == Types::GOODBYE
            object = Wamp::Client::Message::Goodbye.parse(params)
          elsif params[0] == Types::ERROR
            object = Wamp::Client::Message::Error.parse(params)
          elsif params[0] == Types::PUBLISH
            object = Wamp::Client::Message::Publish.parse(params)
          elsif params[0] == Types::PUBLISHED
            object = Wamp::Client::Message::Published.parse(params)
          elsif params[0] == Types::SUBSCRIBE
            object = Wamp::Client::Message::Subscribe.parse(params)
          elsif params[0] == Types::SUBSCRIBED
            object = Wamp::Client::Message::Subscribed.parse(params)
          elsif params[0] == Types::UNSUBSCRIBE
            object = Wamp::Client::Message::Unsubscribe.parse(params)
          elsif params[0] == Types::UNSUBSCRIBED
            object = Wamp::Client::Message::Unsubscribed.parse(params)
          elsif params[0] == Types::EVENT
            object = Wamp::Client::Message::Event.parse(params)
          elsif params[0] == Types::CALL
            object = Wamp::Client::Message::Call.parse(params)
          elsif params[0] == Types::CANCEL
            object = Wamp::Client::Message::Cancel.parse(params)
          elsif params[0] == Types::RESULT
            object = Wamp::Client::Message::Result.parse(params)
          elsif params[0] == Types::REGISTER
            object = Wamp::Client::Message::Register.parse(params)
          elsif params[0] == Types::REGISTERED
            object = Wamp::Client::Message::Registered.parse(params)
          elsif params[0] == Types::UNREGISTER
            object = Wamp::Client::Message::Unregister.parse(params)
          elsif params[0] == Types::UNREGISTERED
            object = Wamp::Client::Message::Unregistered.parse(params)
          elsif params[0] == Types::INVOCATION
            object = Wamp::Client::Message::Invocation.parse(params)
          elsif params[0] == Types::INTERRUPT
            object = Wamp::Client::Message::Interrupt.parse(params)
          elsif params[0] == Types::YIELD
            object = Wamp::Client::Message::Yield.parse(params)
          end

          object
        end
      end

      # Hello
      # Sent by a Client to initiate opening of a WAMP session to a Router attaching to a Realm.
      # Formats:
      #   [HELLO, Realm|uri, Details|dict]
      class Hello < Base
        attr_accessor :realm, :details

        def initialize(realm, details)

          self.class.check_uri('realm', realm)
          self.class.check_dict('details', details)

          self.realm = realm
          self.details = details

        end

        def self.type
          Types::HELLO
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.realm)
          payload.push(self.details)

          payload
        end

        def to_s
          'HELLO > ' + self.payload.to_s
        end

      end

      # Welcome
      # Sent by a Router to accept a Client.  The WAMP session is now open.
      # Formats:
      #   [WELCOME, Session|id, Details|dict]
      class Welcome < Base
        attr_accessor :session, :details

        def initialize(session, details)

          self.class.check_id('session', session)
          self.class.check_dict('details', details)

          self.session = session
          self.details = details

        end

        def self.type
          Types::WELCOME
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.session)
          payload.push(self.details)

          payload
        end

        def to_s
          'WELCOME > ' + self.payload.to_s
        end

      end

      # Abort
      # Sent by a Peer*to abort the opening of a WAMP session.  No response is expected.
      # Formats:
      #   [ABORT, Details|dict, Reason|uri]
      class Abort < Base
        attr_accessor :details, :reason

        def initialize(details, reason)

          self.class.check_dict('details', details)
          self.class.check_uri('reason', reason)

          self.details = details
          self.reason = reason

        end

        def self.type
          Types::ABORT
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.details)
          payload.push(self.reason)

          payload
        end

        def to_s
          'ABORT > ' + self.payload.to_s
        end

      end

      # Goodbye
      # Sent by a Peer to close a previously opened WAMP session.  Must be echo'ed by the receiving Peer.
      # Formats:
      #   [GOODBYE, Details|dict, Reason|uri]
      class Goodbye < Base
        attr_accessor :details, :reason

        def initialize(details, reason)

          self.class.check_dict('details', details)
          self.class.check_uri('reason', reason)

          self.details = details
          self.reason = reason

        end

        def self.type
          Types::GOODBYE
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.details)
          payload.push(self.reason)

          payload
        end

        def to_s
          'GOODBYE > ' + self.payload.to_s
        end

      end

      # Error
      # Error reply sent by a Peer as an error response to different kinds of requests.
      # Formats:
      #   [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri]
      #   [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Arguments|list]
      #   [ERROR, REQUEST.Type|int, REQUEST.Request|id, Details|dict, Error|uri, Arguments|list, ArgumentsKw|dict]
      class Error < Base
        attr_accessor :request_type, :request_request, :details, :error, :arguments, :argumentskw

        def initialize(request_type, request_request, details, error, arguments=nil, argumentskw=nil)

          self.class.check_int('request_type', request_type)
          self.class.check_id('request_request', request_request)
          self.class.check_dict('details', details)
          self.class.check_uri('error', error)
          self.class.check_list('arguments', arguments, true)
          self.class.check_dict('argumentskw', argumentskw, true)

          self.request_type = request_type
          self.request_request = request_request
          self.details = details
          self.error = error
          self.arguments = arguments
          self.argumentskw = argumentskw

        end

        def self.type
          Types::ERROR
        end

        def self.parse(params)

          self.check_gte('params list', 5, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.arguments ||= []
          self.argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.request_type)
          payload.push(self.request_request)
          payload.push(self.details)
          payload.push(self.error)

          return payload if (self.arguments.empty? and self.argumentskw.empty?)
          payload.push(self.arguments)

          return payload if (self.argumentskw.empty?)
          payload.push(self.argumentskw)

          payload
        end

        def to_s
          'ERROR > ' + self.payload.to_s
        end

      end

      # Publish
      # Sent by a Publisher to a Broker to publish an event.
      # Formats:
      #   [PUBLISH, Request|id, Options|dict, Topic|uri]
      #   [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list]
      #   [PUBLISH, Request|id, Options|dict, Topic|uri, Arguments|list, ArgumentsKw|dict]
      class Publish < Base
        attr_accessor :request, :options, :topic, :arguments, :argumentskw

        def initialize(request, options, topic, arguments=nil, argumentskw=nil)

          self.class.check_id('request', request)
          self.class.check_dict('options', options)
          self.class.check_uri('topic', topic)
          self.class.check_list('arguments', arguments, true)
          self.class.check_dict('argumentskw', argumentskw, true)

          self.request = request
          self.options = options
          self.topic = topic
          self.arguments = arguments
          self.argumentskw = argumentskw

        end

        def self.type
          Types::PUBLISH
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.arguments ||= []
          self.argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.options)
          payload.push(self.topic)

          return payload if (self.arguments.empty? and self.argumentskw.empty?)
          payload.push(self.arguments)

          return payload if (self.argumentskw.empty?)
          payload.push(self.argumentskw)

          payload
        end

        def to_s
          'PUBLISH > ' + self.payload.to_s
        end

      end

      # Published
      # Acknowledge sent by a Broker to a Publisher for acknowledged publications.
      # Formats:
      #   [PUBLISHED, PUBLISH.Request|id, Publication|id]
      class Published < Base
        attr_accessor :publish_request, :publication

        def initialize(publish_request, publication)

          self.class.check_id('publish_request', publish_request)
          self.class.check_id('publication', publication)

          self.publish_request = publish_request
          self.publication = publication

        end

        def self.type
          Types::PUBLISHED
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.publish_request)
          payload.push(self.publication)

          payload
        end

        def to_s
          'PUBLISHED > ' + self.payload.to_s
        end

      end

      # Subscribe
      # Subscribe request sent by a Subscriber to a Broker to subscribe to a topic.
      # Formats:
      #   [SUBSCRIBE, Request|id, Options|dict, Topic|uri]
      class Subscribe < Base
        attr_accessor :request, :options, :topic

        def initialize(request, options, topic)

          self.class.check_id('request', request)
          self.class.check_dict('options', options)
          self.class.check_uri('topic', topic)

          self.request = request
          self.options = options
          self.topic = topic

        end

        def self.type
          Types::SUBSCRIBE
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.options)
          payload.push(self.topic)

          payload
        end

        def to_s
          'SUBSCRIBE > ' + self.payload.to_s
        end

      end

      # Subscribed
      # Acknowledge sent by a Broker to a Subscriber to acknowledge a subscription.
      # Formats:
      #   [SUBSCRIBED, SUBSCRIBE.Request|id, Subscription|id]
      class Subscribed < Base
        attr_accessor :subscribe_request, :subscription

        def initialize(subscribe_request, subscription)

          self.class.check_id('subscribe_request', subscribe_request)
          self.class.check_id('subscription', subscription)

          self.subscribe_request = subscribe_request
          self.subscription = subscription

        end

        def self.type
          Types::SUBSCRIBED
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.subscribe_request)
          payload.push(self.subscription)

          payload
        end

        def to_s
          'SUBSCRIBED > ' + self.payload.to_s
        end

      end

      # Unsubscribe
      # Unsubscribe request sent by a Subscriber to a Broker to unsubscribe a subscription.
      # Formats:
      #   [UNSUBSCRIBE, Request|id, SUBSCRIBED.Subscription|id]
      class Unsubscribe < Base
        attr_accessor :request, :subscribed_subscription

        def initialize(request, subscribed_subscription)

          self.class.check_id('request', request)
          self.class.check_id('subscribed_subscription', subscribed_subscription)

          self.request = request
          self.subscribed_subscription = subscribed_subscription

        end

        def self.type
          Types::UNSUBSCRIBE
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.subscribed_subscription)

          payload
        end

        def to_s
          'UNSUBSCRIBE > ' + self.payload.to_s
        end

      end

      # Unsubscribed
      # Acknowledge sent by a Broker to a Subscriber to acknowledge unsubscription.
      # Formats:
      #   [UNSUBSCRIBED, UNSUBSCRIBE.Request|id]
      class Unsubscribed < Base
        attr_accessor :unsubscribe_request

        def initialize(unsubscribe_request)

          self.class.check_id('unsubscribe_request', unsubscribe_request)

          self.unsubscribe_request = unsubscribe_request

        end

        def self.type
          Types::UNSUBSCRIBED
        end

        def self.parse(params)

          self.check_gte('params list', 2, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.unsubscribe_request)

          payload
        end

        def to_s
          'UNSUBSCRIBED > ' + self.payload.to_s
        end

      end

      # Event
      # Event dispatched by Broker to Subscribers for subscriptions the event was matching.
      # Formats:
      #   [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict]
      #   [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Arguments|list]
      #   [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict, PUBLISH.Arguments|list, PUBLISH.ArgumentsKw|dict]
      class Event < Base
        attr_accessor :subscribed_subscription, :published_publication, :details, :publish_arguments, :publish_argumentskw

        def initialize(subscribed_subscription, published_publication, details, publish_arguments=nil, publish_argumentskw=nil)

          self.class.check_id('subscribed_subscription', subscribed_subscription)
          self.class.check_id('published_publication', published_publication)
          self.class.check_dict('details', details)
          self.class.check_list('publish_arguments', publish_arguments, true)
          self.class.check_dict('publish_argumentskw', publish_argumentskw, true)

          self.subscribed_subscription = subscribed_subscription
          self.published_publication = published_publication
          self.details = details
          self.publish_arguments = publish_arguments
          self.publish_argumentskw = publish_argumentskw

        end

        def self.type
          Types::EVENT
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.publish_arguments ||= []
          self.publish_argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.subscribed_subscription)
          payload.push(self.published_publication)
          payload.push(self.details)

          return payload if (self.publish_arguments.empty? and self.publish_argumentskw.empty?)
          payload.push(self.publish_arguments)

          return payload if (self.publish_argumentskw.empty?)
          payload.push(self.publish_argumentskw)

          payload
        end

        def to_s
          'EVENT > ' + self.payload.to_s
        end

      end

      # Call
      # Call as originally issued by the _Caller_ to the _Dealer_.
      # Formats:
      #   [CALL, Request|id, Options|dict, Procedure|uri]
      #   [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list]
      #   [CALL, Request|id, Options|dict, Procedure|uri, Arguments|list, ArgumentsKw|dict]
      class Call < Base
        attr_accessor :request, :options, :procedure, :arguments, :argumentskw

        def initialize(request, options, procedure, arguments=nil, argumentskw=nil)

          self.class.check_id('request', request)
          self.class.check_dict('options', options)
          self.class.check_uri('procedure', procedure)
          self.class.check_list('arguments', arguments, true)
          self.class.check_dict('argumentskw', argumentskw, true)

          self.request = request
          self.options = options
          self.procedure = procedure
          self.arguments = arguments
          self.argumentskw = argumentskw

        end

        def self.type
          Types::CALL
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.arguments ||= []
          self.argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.options)
          payload.push(self.procedure)

          return payload if (self.arguments.empty? and self.argumentskw.empty?)
          payload.push(self.arguments)

          return payload if (self.argumentskw.empty?)
          payload.push(self.argumentskw)

          payload
        end

        def to_s
          'CALL > ' + self.payload.to_s
        end

      end

      # Result
      # Result of a call as returned by _Dealer_ to _Caller_.
      # Formats:
      #   [RESULT, CALL.Request|id, Details|dict]
      #   [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list]
      #   [RESULT, CALL.Request|id, Details|dict, YIELD.Arguments|list, YIELD.ArgumentsKw|dict]
      class Result < Base
        attr_accessor :call_request, :details, :yield_arguments, :yield_argumentskw

        def initialize(call_request, details, yield_arguments=nil, yield_argumentskw=nil)

          self.class.check_id('call_request', call_request)
          self.class.check_dict('details', details)
          self.class.check_list('yield_arguments', yield_arguments, true)
          self.class.check_dict('yield_argumentskw', yield_argumentskw, true)

          self.call_request = call_request
          self.details = details
          self.yield_arguments = yield_arguments
          self.yield_argumentskw = yield_argumentskw

        end

        def self.type
          Types::RESULT
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.yield_arguments ||= []
          self.yield_argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.call_request)
          payload.push(self.details)

          return payload if (self.yield_arguments.empty? and self.yield_argumentskw.empty?)
          payload.push(self.yield_arguments)

          return payload if (self.yield_argumentskw.empty?)
          payload.push(self.yield_argumentskw)

          payload
        end

        def to_s
          'RESULT > ' + self.payload.to_s
        end

      end

      # Register
      # A _Callees_ request to register an endpoint at a _Dealer_.
      # Formats:
      #   [REGISTER, Request|id, Options|dict, Procedure|uri]
      class Register < Base
        attr_accessor :request, :options, :procedure

        def initialize(request, options, procedure)

          self.class.check_id('request', request)
          self.class.check_dict('options', options)
          self.class.check_uri('procedure', procedure)

          self.request = request
          self.options = options
          self.procedure = procedure

        end

        def self.type
          Types::REGISTER
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.options)
          payload.push(self.procedure)

          payload
        end

        def to_s
          'REGISTER > ' + self.payload.to_s
        end

      end

      # Registered
      # Acknowledge sent by a _Dealer_ to a _Callee_ for successful registration.
      # Formats:
      #   [REGISTERED, REGISTER.Request|id, Registration|id]
      class Registered < Base
        attr_accessor :register_request, :registration

        def initialize(register_request, registration)

          self.class.check_id('register_request', register_request)
          self.class.check_id('registration', registration)

          self.register_request = register_request
          self.registration = registration

        end

        def self.type
          Types::REGISTERED
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.register_request)
          payload.push(self.registration)

          payload
        end

        def to_s
          'REGISTERED > ' + self.payload.to_s
        end

      end

      # Unregister
      # A _Callees_ request to unregister a previously established registration.
      # Formats:
      #   [UNREGISTER, Request|id, REGISTERED.Registration|id]
      class Unregister < Base
        attr_accessor :request, :registered_registration

        def initialize(request, registered_registration)

          self.class.check_id('request', request)
          self.class.check_id('registered_registration', registered_registration)

          self.request = request
          self.registered_registration = registered_registration

        end

        def self.type
          Types::UNREGISTER
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.registered_registration)

          payload
        end

        def to_s
          'UNREGISTER > ' + self.payload.to_s
        end

      end

      # Unregistered
      # Acknowledge sent by a _Dealer_ to a _Callee_ for successful unregistration.
      # Formats:
      #   [UNREGISTERED, UNREGISTER.Request|id]
      class Unregistered < Base
        attr_accessor :unregister_request

        def initialize(unregister_request)

          self.class.check_id('unregister_request', unregister_request)

          self.unregister_request = unregister_request

        end

        def self.type
          Types::UNREGISTERED
        end

        def self.parse(params)

          self.check_gte('params list', 2, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.unregister_request)

          payload
        end

        def to_s
          'UNREGISTERED > ' + self.payload.to_s
        end

      end

      # Invocation
      # Actual invocation of an endpoint sent by _Dealer_ to a _Callee_.
      # Formats:
      #   [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict]
      #   [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, CALL.Arguments|list]
      #   [INVOCATION, Request|id, REGISTERED.Registration|id, Details|dict, CALL.Arguments|list, CALL.ArgumentsKw|dict]
      class Invocation < Base
        attr_accessor :request, :registered_registration, :details, :call_arguments, :call_argumentskw

        def initialize(request, registered_registration, details, call_arguments=nil, call_argumentskw=nil)

          self.class.check_id('request', request)
          self.class.check_id('registered_registration', registered_registration)
          self.class.check_dict('details', details)
          self.class.check_list('call_arguments', call_arguments, true)
          self.class.check_dict('call_argumentskw', call_argumentskw, true)

          self.request = request
          self.registered_registration = registered_registration
          self.details = details
          self.call_arguments = call_arguments
          self.call_argumentskw = call_argumentskw

        end

        def self.type
          Types::INVOCATION
        end

        def self.parse(params)

          self.check_gte('params list', 4, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.call_arguments ||= []
          self.call_argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.request)
          payload.push(self.registered_registration)
          payload.push(self.details)

          return payload if (self.call_arguments.empty? and self.call_argumentskw.empty?)
          payload.push(self.call_arguments)

          return payload if (self.call_argumentskw.empty?)
          payload.push(self.call_argumentskw)

          payload
        end

        def to_s
          'INVOCATION > ' + self.payload.to_s
        end

      end

      # Yield
      # Actual yield from an endpoint sent by a _Callee_ to _Dealer_.
      # Formats:
      #   [YIELD, INVOCATION.Request|id, Options|dict]
      #   [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list]
      #   [YIELD, INVOCATION.Request|id, Options|dict, Arguments|list, ArgumentsKw|dict]
      class Yield < Base
        attr_accessor :invocation_request, :options, :arguments, :argumentskw

        def initialize(invocation_request, options, arguments=nil, argumentskw=nil)

          self.class.check_id('invocation_request', invocation_request)
          self.class.check_dict('options', options)
          self.class.check_list('arguments', arguments, true)
          self.class.check_dict('argumentskw', argumentskw, true)

          self.invocation_request = invocation_request
          self.options = options
          self.arguments = arguments
          self.argumentskw = argumentskw

        end

        def self.type
          Types::YIELD
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload
          self.arguments ||= []
          self.argumentskw ||= {}

          payload = [self.class.type]
          payload.push(self.invocation_request)
          payload.push(self.options)

          return payload if (self.arguments.empty? and self.argumentskw.empty?)
          payload.push(self.arguments)

          return payload if (self.argumentskw.empty?)
          payload.push(self.argumentskw)

          payload
        end

        def to_s
          'YIELD > ' + self.payload.to_s
        end

      end

      # Challenge
      # The "CHALLENGE" message is used with certain Authentication Methods. During authenticated session establishment, a *Router* sends a challenge message.
      # Formats:
      #   [CHALLENGE, AuthMethod|string, Extra|dict]
      class Challenge < Base
        attr_accessor :authmethod, :extra

        def initialize(authmethod, extra)

          self.class.check_string('authmethod', authmethod)
          self.class.check_dict('extra', extra)

          self.authmethod = authmethod
          self.extra = extra

        end

        def self.type
          Types::CHALLENGE
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.authmethod)
          payload.push(self.extra)

          payload
        end

        def to_s
          'CHALLENGE > ' + self.payload.to_s
        end

      end

      # Authenticate
      # The "AUTHENTICATE" message is used with certain Authentication Methods.  A *Client* having received a challenge is expected to respond by sending a signature or token.
      # Formats:
      #   [AUTHENTICATE, Signature|string, Extra|dict]
      class Authenticate < Base
        attr_accessor :signature, :extra

        def initialize(signature, extra)

          self.class.check_string('signature', signature)
          self.class.check_dict('extra', extra)

          self.signature = signature
          self.extra = extra

        end

        def self.type
          Types::AUTHENTICATE
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.signature)
          payload.push(self.extra)

          payload
        end

        def to_s
          'AUTHENTICATE > ' + self.payload.to_s
        end

      end

      # Cancel
      # The "CANCEL" message is used with the Call Canceling advanced feature.  A _Caller_ can cancel and issued call actively by sending a cancel message to the _Dealer_.
      # Formats:
      #   [CANCEL, CALL.Request|id, Options|dict]
      class Cancel < Base
        attr_accessor :call_request, :options

        def initialize(call_request, options)

          self.class.check_id('call_request', call_request)
          self.class.check_dict('options', options)

          self.call_request = call_request
          self.options = options

        end

        def self.type
          Types::CANCEL
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.call_request)
          payload.push(self.options)

          payload
        end

        def to_s
          'CANCEL > ' + self.payload.to_s
        end

      end

      # Interrupt
      # The "INTERRUPT" message is used with the Call Canceling advanced feature.  Upon receiving a cancel for a pending call, a _Dealer_ will issue an interrupt to the _Callee_.
      # Formats:
      #   [INTERRUPT, INVOCATION.Request|id, Options|dict]
      class Interrupt < Base
        attr_accessor :invocation_request, :options

        def initialize(invocation_request, options)

          self.class.check_id('invocation_request', invocation_request)
          self.class.check_dict('options', options)

          self.invocation_request = invocation_request
          self.options = options

        end

        def self.type
          Types::INTERRUPT
        end

        def self.parse(params)

          self.check_gte('params list', 3, params.count)
          self.check_equal('message type', self.type, params[0])

          params.shift
          self.new(*params)

        end

        def payload

          payload = [self.class.type]
          payload.push(self.invocation_request)
          payload.push(self.options)

          payload
        end

        def to_s
          'INTERRUPT > ' + self.payload.to_s
        end

      end

    end
  end
end
